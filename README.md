# xv6-thread

이 프로젝트는 MIT의 xv6 운영체제를 기반으로 멀티스레드 기능을 추가 구현한 것입니다. 이를 통해 xv6에서 멀티스레딩을 지원하고, 스레드 간의 동기화 문제를 해결할 수 있도록 했습니다.

## 원 프로젝트 정보

이 프로젝트는 [MIT xv6](https://pdos.csail.mit.edu/6.828/2022/xv6.html) 운영체제를 기반으로 합니다. xv6는 Unix v6를 x86 아키텍처에 맞게 재구현한 교육용 운영체제입니다. 

xv6의 소스 코드는 Frans Kaashoek, Robert Morris, Russ Cox가 저작권을 갖고 있습니다. 자세한 내용은 [GitHub 저장소](https://github.com/mit-pdos/xv6-riscv)를 참조하세요.

## 추가 구현 사항

### clone, join 시스템 콜

이 프로젝트에서는 xv6에 clone() 시스템 콜을 추가하여 멀티스레드 기능을 구현했습니다. clone() 시스템 콜은 새로운 스레드를 생성하며, 해당 스레드는 부모 프로세스와 동일한 주소 공간을 공유합니다. 이를 위해 프로세스 구조체에 스레드를 위한 필드(tid, is_thread_parent)를 추가하였으며, allocproc 함수에서 이러한 필드들을 초기화하도록 수정했습니다.

clone() 시스템 콜은 새로운 스레드를 생성하기 위해 현재 프로세스의 주소 공간과 스레드 컨텍스트를 복사합니다. 스택은 독립적인 공간을 가지며, 이를 위해 clone() 호출 시 스택 공간을 매개변수로 전달받아 설정합니다. 이 과정에서 스택 포인터와 베이스 포인터를 적절히 조정하고, 부모 스레드의 스택을 복사하여 새 스레드의 스택을 초기화합니다.

join() 시스템 콜은 현재 프로세스의 자식 스레드가 종료될 때까지 기다렸다가, 해당 스레드를 정리하는 기능을 합니다. 이는 wait() 시스템 콜과 유사하지만, 스레드 간의 동기화에 중점을 둡니다. join() 시스템 콜은 자식 스레드가 종료되면 해당 스레드의 자원을 해제하고, 스레드 ID를 반환합니다. 이를 통해 스레드가 종료될 때까지 부모 스레드가 대기하고, 자원을 적절히 관리할 수 있습니다.

clone()과 join() 시스템 콜의 구현은 운영체제 내부에서 프로세스와 스레드를 관리하는 방법에 대한 이해를 높이는 데 도움이 되었습니다. 이는 프로세스와 스레드의 생성, 종료, 동기화 등의 개념을 깊이 있게 학습하는 기회가 되었습니다.

### thread_create, thread_join API

thread_create()는 사용자 레벨에서 스레드를 생성하기 위한 API로, 내부적으로 clone() 시스템 콜을 호출하여 새로운 스레드를 생성합니다. 이 API는 새로운 스레드가 시작할 함수를 매개변수로 받아, 해당 함수를 실행하도록 합니다. 또한, 스레드를 위한 스택을 동적으로 할당하고, 스레드가 종료되면 스택을 해제하는 기능을 포함합니다. 이를 통해 스레드 생성을 간편하게 하고, 자원 관리를 효율적으로 할 수 있습니다.
thread_join()는 특정 스레드가 종료될 때까지 대기하는 API로, 내부적으로 join() 시스템 콜을 호출합니다. 이 API는 주어진 스레드 ID를 인수로 받아 해당 스레드가 종료될 때까지 대기하고, 스레드가 종료되면 0을 반환합니다. 이를 통해 스레드 간의 동기화와 자원 관리를 용이하게 합니다.
thread_create()와 thread_join() API의 구현은 사용자 레벨에서 스레드를 생성하고 관리하는 방법을 익히는 데 도움이 되었습니다. 이는 실제 응용 프로그램에서 멀티스레딩을 활용하는 방법과 그 과정에서 발생할 수 있는 이슈들을 이해하는 데 기여했습니다.

### mutex_lock, mutex_unlock 시스템 콜

멀티스레드 환경에서 동기화를 위해 mutex_lock() 및 mutex_unlock() 시스템 콜을 구현했습니다. mutex_lock()은 주어진 락 변수를 사용하여 락을 획득하려 시도하며, 실패하면 해당 스레드가 락을 획득할 때까지 대기합니다. mutex_unlock()은 락을 해제하고, 대기 중인 스레드를 깨웁니다. 이를 통해 스레드 간의 상호 배제를 보장하고, 동기화 문제를 해결할 수 있습니다.
mutex_lock()과 mutex_unlock() 시스템 콜의 구현은 운영체제 수준에서 동기화 기술을 어떻게 제공하는지 이해하는 데 도움이 되었습니다. 이는 실제 시스템 프로그래밍에서 중요한 개념인 상호 배제와 동기화를 다루는 방법을 학습하는 좋은 기회가 되었습니다.

### 프로젝트의 의의

이 프로젝트는 운영체제 내부의 프로세스와 스레드 관리, 동기화 등의 핵심 개념을 이해하고 구현하는 경험을 제공했습니다. 이는 시스템 프로그래밍과 운영체제에 대한 깊이 있는 지식을 쌓는 데 기여했습니다.
또한, 이 프로젝트는 저의 백엔드 개발자로서의 역량 강화에도 도움이 되었습니다. 멀티스레딩과 동기화는 서버 프로그래밍에서 핵심적인 개념이며, 이를 운영체제 수준에서 다뤄본 경험은 고성능 서버 애플리케이션을 개발하는 데 있어 좋은 기반이 될 것입니다. 특히, 스프링 프레임워크에서 제공하는 멀티스레딩 및 동기화 기능을 보다 깊이 이해하고 활용하는 데 도움이 될 것으로 기대합니다.
이 프로젝트는 제가 시스템 프로그래밍과 운영체제에 대한 전문성을 갖춘 백엔드 개발자로 성장하는 데 기여한 의미 있는 경험이었습니다. 앞으로도 이러한 경험을 바탕으로 고성능, 고가용성의 서버 애플리케이션을 개발하는 역량 있는 개발자가 되기 위해 노력하겠습니다.
